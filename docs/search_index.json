[
["index.html", "Notes Chapter 1 Diffusion 1.1 Basket 1.2 Worst-of 1.3 Best-of", " Notes Ivan Tan 2017-03-05 Chapter 1 Diffusion In no-arbitrage pricing we one way to model a stock diffusion is using the following GBM model: \\[S_T = S_0 \\cdot e^{\\Big( r-d-q -\\frac{1}{2}\\sigma^2 \\Big)\\cdot T + \\sigma \\sqrt{T}\\cdot W_T } \\] Given the drift and volatility parameters we can simulate sample final spot levels as such: aSampleSpotT = function(s0, r, d, q, sig, dt, nsims) { sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * rnorm(nsims) * sqrt(dt)) sT } cat(&quot;Spot after 1 year: &quot;, aSampleSpotT(1, 0.04, 0.01, 0, 0.2, 1, 1)) ## Spot after 1 year: 0.9048997 If required we could compute over several short periods to create a trajectory. Then repeat it many times to see how the diffusion is going to look like. Assuming we will drift the equity by 0% p.a., that is \\(r - d - q = 0\\), and it has annualised volatility of 20%, Let’s plot several trajectories or paths. See Figure 1.1: numSteps = 52 # weekly oneTraj = rep(1, numSteps) for (i in 2:numSteps) oneTraj[i] = aSampleSpotT(oneTraj[i-1], 0, 0, 0, 0.2, 1/numSteps, 1) cat(&quot;First 5 weekly close: &quot;, oneTraj[1:5]) ## First 5 weekly close: 1 1.029598 0.9638758 0.9302029 0.9045659 par(mfrow = c(1, 2)) plot(oneTraj, type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(manyTraj), max(manyTraj))) box() axis(side = 2) plot(manyTraj[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(manyTraj), max(manyTraj))) box() axis(side = 2) for (i in 2:nrow(manyTraj)) lines(manyTraj[i,], type = &quot;l&quot;) Figure 1.1: Left: 1 path, Right: 50 paths 1.1 Basket What was done above assumed each path (which can be though as one underlying by itself) is independent of another, although with the same drift and volatility. However, when attempting to simulate several underlyings, it would not be unreasonable to consider the underlyings are correlated, even with different market parameters. As an example we have a basket on three underlyings, their log returns all have pairwise correlation of 90%, see Table 1.1. The (multivariate) GBM process can be extended to correlated underlyings, with their correlations preserved in the multivariate random process. One way of generating a correlated multivariate random \\(W_T\\) vector is to left-multiply a lower triangle Cholesky decomposed correlation matrix to an uncorrelated random vector.1 2 corr_more = matrix(c(1.0, 0.9, 0.9, 0.9, 1.0, 0.9, 0.9, 0.9, 1.0), nrow = 3, dimnames = list(c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;), c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;))) Table 1.1: 3 highly correlated underlyings undl1 undl2 undl3 undl1 1.0 0.9 0.9 undl2 0.9 1.0 0.9 undl3 0.9 0.9 1.0 corrSpot = function(s0, r, d, q, sig, dt, corrMat) { numUndls = nrow(corrMat) correlatedRV = as.double(t(chol(corrMat)) %*% rnorm(numUndls)) sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * correlatedRV * sqrt(dt)) sT } numUndls = nrow(corr_more) numSteps = 52 # weekly corrTraj = matrix(rep(1, numSteps*numUndls), nrow = numUndls) for (i in 2:numSteps) corrTraj[,i] = corrSpot(corrTraj[,i-1], 0, 0, 0, 0.2, 1/numSteps, corr_more) print(corrTraj[,1:5]) # First 5 weekly close of 3 correlated undls ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0.9921613 0.9449369 0.9508708 0.9184217 ## [2,] 1 0.9845248 0.9302299 0.9269184 0.8951975 ## [3,] 1 0.9812859 0.9260241 0.9470284 0.9181487 Sample paths of the underlyings. Underlying 1 in Black, Underlying 2 in Red, and Underlying 3 in Green. See Figure 1.2: Figure 1.2: Separate simulations of the basket trajectories 1.2 Worst-of From a basket of underlyings, we could choose the lowest performing underlying and call it the worst-of underlying. Doing this selection over the entire tenor we can visual what a worst-of trajectory looks like. corr_less = matrix(c(1.0, 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0), nrow = 3, dimnames = list(c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;), c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;))) corrTraj2 = matrix(rep(1, numSteps*numUndls), nrow = numUndls) for (i in 2:numSteps) corrTraj2[,i] = corrSpot(corrTraj2[,i-1], 0, 0, 0, 0.15, 1/numSteps, corr_less) To make it obvious that a worst-of “underlying” can be different as different point of time, we choose to create a much lower correlation basket of underlyings, and reduced the annualised volatility to 15%. In this stylised result we see how the worst-of underlying can change over time. print(corrTraj2[,1:5]) # First 5 weekly close of 3 correlated undls ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 1.0341966 1.005334 1.003751 0.9971818 ## [2,] 1 1.0380406 1.054187 1.026348 0.9791170 ## [3,] 1 0.9984069 1.009408 1.001214 0.9934616 woTraj = apply(corrTraj2, 2, min) print(woTraj[1:5]) # First 5 weekly close of the worst &quot;underlying&quot; ## [1] 1.0000000 0.9984069 1.0053336 1.0012137 0.9791170 Let’s plot a one sample of the basket trajectories, then overlap with the worst-of “underlying” (in blue). See Figure 1.3: par(mfrow = c(1, 2)) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = basketCols[i]) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, col = &quot;azure3&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = &quot;azure3&quot;) lines(woTraj, type = &quot;l&quot;, col = &quot;blue&quot;) Figure 1.3: A basket of 3 underlyings (in grey) and the worst-of underlying (in blue) When I first started it made no sense why anyone would want to buy a call option that tracks the worst performance. Turns out it meant for investors who have a bullish view on a basket of underlyings. Tracking on the worst-of is a lot cheaper than buying a call that is based of the average performance. As we’ll see in Chapter 3, this makes possible some interesting exotic payoffs. 1.3 Best-of Having seen a worst-of underlying, there is no reason why we cannot have a best-of version. This time we select the best performing underlying instead of the worst. Unless the worst-of call, the best-of call is more expensive than basing of an average performance of the basket of underlying. However if you have a bearish view, buying a put or shorting a call is now a lot more attractive. print(corrTraj2[,1:5]) # First 5 weekly close of 3 correlated undls ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 1.0341966 1.005334 1.003751 0.9971818 ## [2,] 1 1.0380406 1.054187 1.026348 0.9791170 ## [3,] 1 0.9984069 1.009408 1.001214 0.9934616 boTraj = apply(corrTraj2, 2, max) print(woTraj[1:5]) # First 5 weekly close of the worst &quot;underlying&quot; ## [1] 1.0000000 0.9984069 1.0053336 1.0012137 0.9791170 Again, we see there is no need for the best-of “underlying” to be the same underlying in the basket from start to end. See Figure 1.4: par(mfrow = c(1, 2)) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = basketCols[i]) plot(corrTraj2[1,], type = &quot;l&quot;, col = &quot;azure3&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = &quot;azure3&quot;) lines(boTraj, type = &quot;l&quot;, col = &quot;blue&quot;) Figure 1.4: A basket of 3 underlyings (in grey) and the best-of underlying (in blue) And with many repeated simulations: Overlaying the best-of “underlying” trajectories: par(mfrow = c(1, 2)) plot(corrTraj_sim[1, , 1], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj_sim), max(corrTraj_sim))) box() axis(side = 2) for (j in 1:numSims) for (i in 1:nrow(corrTraj_sim[, , j])) lines(corrTraj_sim[i, , j], type = &quot;l&quot;, col = basketCols[i]) plot(corrTraj_sim[1, , 1], type = &quot;l&quot;, col = &quot;azure3&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj_sim), max(corrTraj_sim))) box() axis(side = 2) for (j in 1:numSims) for (i in 1:nrow(corrTraj_sim[, , j])) lines(corrTraj_sim[i, , j], type = &quot;l&quot;, col = &quot;azure3&quot;) for (i in 1:numSims){ lines(boTraj_sim[i, ], type = &quot;l&quot;, lwd= 1, col = &quot;blue&quot;) } "],
["sensi.html", "Chapter 2 Sensitivity 2.1 Vol &amp; Smile 2.2 Correl 2.3 Drift", " Chapter 2 Sensitivity TODO: Show general method of finite difference, using forward difference and centered difference. Use it to compute, first order greeks. 2.1 Vol &amp; Smile TODO: Show that most exotic products are highly sensitive to vol surface. Term structure and skew creates the need for usage local volatility model. Generally product are vol and smile bid. TODO: Reconstruct IV surface using options prices. Plot 3d cube. TODO: Build LV surface using IV surface. Plot 3d cube. Show crazy fluctuations if IV is not smooth. TODO: Show that pricing with LV model is equal to price at constant vol. 2.2 Correl TODO: Show that most exotic bullish products are correl offer. Long worst of call = CA, Long worst of put = CA. 2.3 Drift TODO: Show that bullish products are divs and repo bid. "],
["payoff.html", "Chapter 3 Payoff 3.1 Noncallable 3.2 Autocallable 3.3 Issuercallable", " Chapter 3 Payoff From the diffusions created in Chapter 1, we could evaluate them based on the payoff of the product. To start off we price a vanilla call options, then compare the result with the closed form Black Scholes result from Chapter 2. For a 1 year european call option strike at the money on an underlying with zero drift and 20% annualised volatility, we get a price of around 8%. strikeK = 1 diffusions = aSampleSpotT(1, 0, 0, 0, 0.2, 1, 50000) payoffs = pmax(0, diffusions - strikeK) mean(payoffs) ## [1] 0.07907781 Comparing the result to the Black Scholes solution: \\[ \\mathrm C(\\mathrm S,\\mathrm t)= \\mathrm N(\\mathrm d_1)\\mathrm S - \\mathrm N(\\mathrm d_2) \\mathrm K \\mathrm e^{-rt} \\label{eq:2} \\] where \\(d_1\\), \\(d_2\\) and \\(N(x)\\) is defined as: \\[ \\mathrm d_1= \\frac{1}{\\sigma \\sqrt{\\mathrm t}} \\left[\\ln{\\left(\\frac{S}{K}\\right)} + t\\left(r + \\frac{\\sigma^2}{2} \\right) \\right] \\] \\[ \\mathrm d_2= \\frac{1}{\\sigma \\sqrt{\\mathrm t}} \\left[\\ln{\\left(\\frac{S}{K}\\right)} + t\\left(r - \\frac{\\sigma^2}{2} \\right) \\right] \\] \\[ N(x)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} \\mathrm e^{-\\frac{1}{2}z^2} dz \\label{eq:5} \\] Now substituting in the values: \\[ \\mathrm d_1= \\frac{1}{0.2 \\sqrt{1}} \\left[\\ln{\\left(\\frac{1}{1}\\right)} + 1\\left(0 + \\frac{0.2^2}{2} \\right) \\right]= 0.1 \\] \\[ \\mathrm d_1= \\frac{1}{0.2 \\sqrt{1}} \\left[\\ln{\\left(\\frac{1}{1}\\right)} + 1\\left(0 - \\frac{0.2^2}{2} \\right) \\right]=-0.1 \\] \\[ N(d_1)=N(0.1)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{0.1} \\mathrm e^{-\\frac{1}{2}z^2} dz = 0.5398 \\] \\[ N(d_2)=N(-0.1)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{-.1} \\mathrm e^{-\\frac{1}{2}z^2} dz = 0.4602 \\] \\[ \\mathrm C(1,1)= (0.5398)(1) - (0.4602)(1) \\mathrm e^{-(0)(1)} \\approx 0.08 \\] Good start! Here rates, dividends and repo are assumed to be zero. Also that volatility is constant. We could do better by incorporating these changes in later chapters. 3.1 Noncallable Non-callable payoffs are structures that have a fixed maturity. Structures that may terminate earlier than this fixed maturity are called callable payoffs. 3.1.1 Digitals An example of a digit is one that pays X at maturity when the underlying is at or above a certain barrier, and pays nothing when the underlying is below, it is also called a up and in digit option. There are also versions; an up and out digit which the structure pays X unless the underlying is at or above a certain barrier, a down and in digit is equivalent to the up and out digit, and a down and out digit which is the same as a up and in digit. There are also variants of when the knocking in or out observation is carried out. A common type is called the European (or at maturity) observation which checks if the condition is satisfied only once at end of the product tenor. American observation type is as common, which checks for the condition on a daily close frequency. Other variants include quarterly, monthly or intraday observation frequency. set.seed(1) numTraj_digit = 2 manyTraj_digit = matrix(rep(1, numSteps*numTraj_digit), nrow = numTraj_digit) for (i in 2:numSteps) manyTraj_digit[,i] = aSampleSpotT(manyTraj_digit[,i-1], 0, 0, 0, 0.2, 1/numSteps, numTraj_digit) Supposed we have bought two 1 year european up and in digit 10% with barrier striked at 110% on same underlying above. Two sample trajectories below show that path 1 performed +26%, while path 2 only ended up +1%. According to the payoff, the first product will pay a 10% payout while the second product does not. See Figure 3.1: ## Closing price at end of Year 1 for Path 1: 1.264054 ## Closing price at end of Year 1 for Path 2: 1.012484 Figure 3.1: 2 separate trajectories; Left path ends below the strike and receives a 10% payout, the right path does not pay any. Blue line denotes the strike barrier at 110% of initial spot. Pricing such a product is always similar to that of a call option, except when the option is in the money, it pays the digit coupon instead of the performance of the underlying minus its strike. We see it cost about 3%. digitK = 1.1 digitCpn = 0.1 digitPays = (diffusions &gt; digitK)*digitCpn mean(digitPays) ## [1] 0.028146 3.1.2 Put Down and In Like the digital down and in option above, a put down and in option knocks in when an underlying ends below a certain barrier. However, when the condition is satisfied, the put comes into existence and so the payoff is that of a vanilla put option. Therefore we need also need to know the put strike in order to determine the payoff. Let’s say we sell a 1y put down and in on the same underlying as before, with european (at maturity) down and in barrier 80% and strike 100%. For a change of pace we proceed to the price before visualising what a sample path and its payoff is. pdiK = 1 eki80Barrier = 0.8 pdi80Hit = diffusions &lt;= eki80Barrier putPays = pmax(0, pdiK - diffusions) pdi80Pays = putPays*as.double(pdi80Hit) mean(-1 * pdi80Pays) # price of short pdi with eki = 80% and strike = 100% ## [1] -0.04299469 We will use the convention of a negative premium for investor receiving the premium instead of paying the premium. If we think of the knock-in feature on a short put as protection, that is the option seller sold a put that will not be in the money unless the underlying has first broken the knock in barrier, then we should expect a put down and in with european barrier at 80% to bring less value than one with barrier at 90%. Both of which has to be cheaper than a straight put, or a put without knock-in feature. pdi_comparison = c(mean(-1 * pdi80Pays), mean(-1 * pdi90Pays), mean(-1 * putPays)) We see the seller of the different puts receives more if he sold a put down and in with higher knock-in barrier, or when there is no barrier (a put). Looking consistent! By the same argument, a put down and in with american (daily close) knock-in observation type costs more than the european type, since there are more opportunities for the product to be knocked in. We delay this comparison on observation frequency to the next section. In structured products, puts with knock-in features are very common, since they provide some protection for the investors unless the underlying has severely underperformed. set.seed(8) numTraj_pdi = 2 manyTraj_pdi = matrix(rep(1, numSteps*numTraj_pdi), nrow = numTraj_pdi) for (i in 2:numSteps) manyTraj_pdi[,i] = aSampleSpotT(manyTraj_pdi[,i-1], 0, 0, 0, 0.2, 1/numSteps, numTraj_digit) Figure 3.2: 2 separate trajectories; Left: Path is not below the KI barrier, so has no value even though it is below the strike. Right: Path ends below KI barrier. 3.1.3 Call Up and Out 3.1.4 Combinations 3.2 Autocallable 3.2.1 Snowball 3.2.2 Phoenix 3.2.3 Fixed Coupons Notes 3.3 Issuercallable In Progress Also see Chapter 4 "],
["lsmc.html", "Chapter 4 Longstaff Schwartz", " Chapter 4 Longstaff Schwartz In Progress TODO: Show least square regression example to compute expected price, vs exercise/exit price. Determine optimal exercise strategy. "],
["scen.html", "Chapter 5 Scenario", " Chapter 5 Scenario Those interested in exotic payoffs often want to understand the behaviour of the value the product after issuance if some variable (such as spot level) changes. TODO: Show MTM of issued products, at say 3m/6m/9m/matu, and when spot performs -10%/-5%/0%/… Show that the MTM pattern is due to specific product features. "],
["quirk.html", "Chapter 6 Quirkiness 6.1 Inversion 6.2 Gap 6.3 Qto 6.4 Correl", " Chapter 6 Quirkiness Here we look at some interesting behaviour of exotic structures 6.1 Inversion 6.1.1 Delta Even on a bullish payoff, after product issues the delta of a product can become negative when near an certain product features such as an Autocall barrier TODO: Compute delta just before KO observation when just below KO Barrier 6.1.2 Vega On lookback payoffs, the vega during different periods of the product can flip signs TODO: Compute vega during lookback observation period, vs vega after lb obs period. 6.2 Gap Many exotic structures have digital payoffs. For example the put down and in seen in Chapter 3.1.2 can have a jump in value if the barrier is breached. TODO: Compute delta just before barrier to show explosive sensi, or large gamma. 6.3 Qto It is quite common to see structure products issued in product currency which is different from the underlying currency. For example in a 1 year EUR Note linked to APPLE, the holder of the product pays and gets paid in EUR, with the payoff defined entired based on the performance only on the stock. TODO: short formula on payoff only depends on eqty perf 6.4 Correl TODO: Compute price of outperformance between 2 basket (i.e. long basket - short basket). Determine that correlation between long basket and short basket is Bid, correlation within each basket is Offer. "],
["refer.html", "Chapter 7 References", " Chapter 7 References The below made this webpage possible: Bookdown CBOE option price R Github Countless helpful people "]
]
