[
["index.html", "Notes Chapter 1 Preface 1.1 Basket", " Notes 2017-03-14 Chapter 1 Preface In no-arbitrage pricing, one way of modelling a stock diffusion with constant drift and volatility terms is the geometric brownian motion model (wiki): \\[S_T = S_0 \\cdot e^{\\Big( r-d-q -\\frac{1}{2}\\sigma^2 \\Big)\\cdot T + \\sigma \\sqrt{T}\\cdot W_T } \\] Given the market parameters one may simulate samples of spot at time \\(T\\) as such: aSampleSpotT = function(s0, r, d, q, sig, dt, nsims) { sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * rnorm(nsims) * sqrt(dt)) sT } cat(&quot;Spot after 1 year: &quot;, aSampleSpotT(1, 0.04, 0.01, 0, 0.2, 1, 1)) ## Spot after 1 year: 0.9821138 If required it is also possible to iterate over several consecutive periods to generate a path. For example, instead of sampling the spot after 1 year, we sample the spot after 1 week, then use the spot at week 1 to sample the spot at week 2, and so on until we arrive at the final observation as required. By repeatedly and independently generating many such paths we can visualise how the stock diffusion looks like. Assume the stock drifts at 0% per annum, i.e. \\(r - d - q = 0\\), and the stock has constant volatility of 20% per annum, we plot several paths or trajectories. The initial spot price is normalised to 1. Each trajectory below consist of 52 consecutive weekly observations. See Figure 1.1: nSteps = 52 # weekly obs aPath = rep(1, nSteps+1) # initial spot is 1 for (i in 2:(nSteps+1)) aPath[i] = aSampleSpotT(aPath[i-1], 0, 0, 0, 0.2, 1/nSteps, 1) Table 1.1: First 4 weekly close week 1 week 2 week 3 week 4 Spot price 1.024129 1.001771 1.025383 0.9895311 par(mfrow = c(1, 2)) plot(aPath, type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(manyTraj), max(manyTraj))) box() axis(side = 2) plot(manyTraj[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(manyTraj), max(manyTraj))) box() axis(side = 2) for (i in 2:nrow(manyTraj)) lines(manyTraj[i,], type = &quot;l&quot;) Figure 1.1: Left: 1 path, Right: 30 paths 1.1 Basket Each of the 30 paths above can be thought as a different stock, so it could as well be one sample simulation of 30 different independent stocks prices after 1 year. However, when attempting to simulate several underlyings, it would not be unreasonable to consider the underlyings are actually correlated. As an example we have a basket on three underlyings, with log returns of each underlying having pairwise correlation of 90%. See Table 1.2. The (multivariate) GBM process can be extended to underlyings that are correlated. Their correlations are preserved within the multivariate random portion of the process. (wiki) One way of generating a correlated multivariate random \\(W_T\\) vector is to left-multiply a lower triangular Cholesky decomposed matrix to an uncorrelated multivariate random vector.(wiki) (math.SE) corrHigh = matrix(c(1.0, 0.9, 0.9, 0.9, 1.0, 0.9, 0.9, 0.9, 1.0), nrow = 3, dimnames = list(c(&quot;Undl 1&quot;, &quot;Undl 2&quot;, &quot;Undl 3&quot;), c(&quot;Undl 1&quot;, &quot;Undl 2&quot;, &quot;Undl 3&quot;))) Table 1.2: 3 Highly Correlated Underlyings Undl 1 Undl 2 Undl 3 Undl 1 1.0 0.9 0.9 Undl 2 0.9 1.0 0.9 Undl 3 0.9 0.9 1.0 # use correlated random variables instead of independent ones corrSpot = function(s0, r, d, q, sig, dt, corrMat) { nUndls = nrow(corrMat) correlatedRV = as.double(t(chol(corrMat)) %*% rnorm(nUndls)) sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * correlatedRV * sqrt(dt)) sT } nUndls = nrow(corrHigh) nSteps = 52 # weekly obs corrTraj = matrix(rep(1, (nSteps+1)*nUndls), nrow = nUndls) for (i in 2:(nSteps+1)) corrTraj[,i] = corrSpot(corrTraj[,i-1], 0, 0, 0, 0.2, 1/nSteps, corrHigh) Table 1.3: First 4 weekly close of 3 correlated undls Week 1 Week 2 Week 3 Week 4 Undl 1 0.9752654 0.9769363 0.9966085 0.9805188 Undl 2 0.9802384 0.9786300 0.9898269 0.9811299 Undl 3 0.9740695 0.9670629 0.9822644 0.9764641 Sample paths of the underlyings. In black is underlying 1, in red underlying 2, in green underlying 3. See Figure 1.2: Figure 1.2: Two separate simulations of the paths of the underlyings in the basket 1.1.1 Worst-of From a basket of underlyings, we could choose the lowest performing underlying and call it the worst-of underlying. Making this choice over the entire tenor of the product we can visual what a worst-of trajectory looks like. set.seed(999) corrLow = matrix(c(1.0, 0.0, 0.1, 0.0, 1.0, 0.0, 0.1, 0.0, 1.0), nrow = 3, dimnames = list(c(&quot;Undl 1&quot;, &quot;Undl 2&quot;, &quot;Undl 3&quot;), c(&quot;Undl 1&quot;, &quot;Undl 2&quot;, &quot;Undl 3&quot;))) corrTraj2 = matrix(rep(1, (nSteps+1)*nUndls), nrow = nUndls) for (i in 2:(nSteps+1)) corrTraj2[,i] = corrSpot(corrTraj2[,i-1], 0, 0, 0, 0.40, 1/nSteps, corrLow) To make it obvious that a worst-of “underlying” does not have to be the same underlying at different point of time, we chose to create a much lower correlated basket of underlyings. We also chose to fix the annualised volatility of these underlyings constant at 40%. In this stylised result we see how the worst-of underlying may differ over time. print(corrTraj2[,2:5]) # First 4 weekly close of 3 less correlated undls ## [,1] [,2] [,3] [,4] ## [1,] 0.9829799 0.9962827 0.8963073 0.8409755 ## [2,] 0.9283503 0.9127741 0.8495281 0.9129363 ## [3,] 1.0416297 1.0095515 0.9456666 0.9453241 woTraj = apply(corrTraj2, 2, min) print(woTraj[2:5]) # First 4 weekly close of the worst &quot;underlying&quot; ## [1] 0.9283503 0.9127741 0.8495281 0.8409755 Let’s plot one sample of all underlying paths. On the right we overlay the worst-of “underlying” in blue while greying out the actual underlying paths. See Figure 1.3: par(mfrow = c(1, 2)) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = basketCols[i]) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, col = &quot;azure3&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = &quot;azure3&quot;) lines(woTraj, type = &quot;l&quot;, col = &quot;blue&quot;) Figure 1.3: A basket of 3 underlyings (in grey) and the worst-of underlying (in blue) A relevant question is why anyone would want to buy a call option that tracks the worst performance instead of the average performance, since the alternative is very likely to pay more at maturity. The sensible answer is that if the investor has a bullish view on the entire basket, buying a worst-of call option is a lot more affordable than buying a call that is based on the average performance. As we’ll see in Chapter 3, this makes possible some interesting exotic payoffs. 1.1.2 Best-of Having seen a worst-of underlying, there is no reason why we cannot have a best-of version. Unlike the worst-of call option, a best-of call is more expensive than the average of call. However, if you have a bearish view, buying a best-of put is much more affordable. Likewise, selling a best-of call brings the investor much more premium. print(corrTraj2[,1:5]) # First 5 weekly close of 3 correlated undls ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0.9829799 0.9962827 0.8963073 0.8409755 ## [2,] 1 0.9283503 0.9127741 0.8495281 0.9129363 ## [3,] 1 1.0416297 1.0095515 0.9456666 0.9453241 boTraj = apply(corrTraj2, 2, max) print(woTraj[1:5]) # First 5 weekly close of the worst &quot;underlying&quot; ## [1] 1.0000000 0.9283503 0.9127741 0.8495281 0.8409755 Again, we see there is no need for the best-of “underlying” to be the same underlying in the basket from start to end of the product tenor. See Figure 1.4: par(mfrow = c(1, 2)) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = basketCols[i]) plot(corrTraj2[1,], type = &quot;l&quot;, col = &quot;azure3&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = &quot;azure3&quot;) lines(boTraj, type = &quot;l&quot;, col = &quot;blue&quot;) Figure 1.4: A basket of 3 underlyings (in grey) and the best-of underlying (in blue) Now we repeat the over many simulations of the 3 underlyings paths. On the right we overlay in blue the best-of “underlying” of each simulation. "],
["volsurf.html", "Chapter 2 Volatility Surface 2.1 Implied Vol 2.2 Local Vol", " Chapter 2 Volatility Surface Exotic payoffs can be very sensitive to volatility. The existence of a term and skew structure on the volatility surface implies that an underlying is regarded as having different volatility at different spot or time. The sensitivity to volatility means that our estimation of the price needs to incorporate the entire surface as an input. Before thinking about the implications of this, we should provide means of producing the surface. One way is to use the market data of option prices on an underlying to reconstruct the implied volatility surface. Below we demostrate how to construct the SPX implied volatility surface using option prices from CBOE. CBOEhttp://www.cboe.com/delayedquote/quote-table-download provides downloading of delayed option quotes. If we enter SPX as the index ticker we can obtain a table that looks like this: ## Spec PBid PAsk CP Type ## 1 17 Feb 500.00 (SPXW1728B500) 1864.8 1868.5 C Euro ## 2 17 Feb 500.00 (SPXW1728B500-E) 1864.8 1868.5 C Euro ## 3 17 Feb 600.00 (SPXW1728B600) 1764.8 1768.5 C Euro ## 4 17 Feb 600.00 (SPXW1728B600-E) 1764.8 1768.5 C Euro ## 5 17 Feb 700.00 (SPXW1728B700) 1664.8 1668.5 C Euro ## 6 17 Feb 700.00 (SPXW1728B700-E) 1664.8 1668.5 C Euro The data contains enough information to reproduce an implied volatility that leads to the quoted price of an option. 2.1 Implied Vol Generally the market data does not contain sufficient data points, we therefore make a decision to interpolate within the points. Here we create a 40 by 40 equidistance grid of points so that the plot will look smooth. df_call &lt;- subset(SPX.IV, Type == &quot;C&quot;) df_call$StrikePct = df_call$Strike/df_call$Spot x &lt;- df_call$StrikePct y &lt;- as.numeric(df_call$dtExpiry) z &lt;- df_call$IVMid s &lt;- interp(x, y, z, nx=40, ny = 40, linear = T) nrz = nrow(s$z) ncz = ncol(s$z) jet.colors = colorRampPalette(c(&quot;blue&quot;, &quot;green&quot;)) nbcol = 100 color = jet.colors(nbcol) zfacet = s$z[-1, -1] + s$z[-1, -ncz] + s$z[-nrz, -1] + s$z[-nrz, -ncz] facetcol = cut(zfacet, nbcol) TTM &lt;- as.numeric(as.Date(s$y, origin = &quot;1970-01-01&quot;) - df_call$dtTrade[1])/365 persp(s$x, TTM, s$z * 100, col = color[facetcol], xlab = &quot;\\nMoneyness&quot;, ylab = &quot;\\nExpiry (Yr)&quot;, zlab = &quot;\\nVolatility (%)&quot;, theta = 40, phi = 25, ticktype = &quot;detailed&quot;) From the plot we see the volatility is moving in the opposite direction of moneyness. Moneyness was computed as the strike price divided by the spot price. We can understand also interpret this as the implied volatility being higher when strike price is lower than the spot price. However this is not always true, there other sections of the surface (further strikes and expiries) where the curvature is differently shaped. That is, in far out (or in) of the region shown above, the shape can be upward sloping instead of downward sloping. 2.2 Local Vol TODO: Build LV surface using IV surface. Plot 3d chart. Show fluctuations if IV data points are not smooth. "],
["payoff.html", "Chapter 3 Payoff 3.1 Noncallable 3.2 Callable", " Chapter 3 Payoff From the diffusions created in Chapter 1, we could evaluate them based on the payoff of the product. To start off we price a vanilla call option, then compare the result with the closed-form Black Scholes solution. For a 1 year european call option strike at the money on an underlying with zero drift and constant 20% annualised volatility, we see the stimulations gave a price of about 8%. strikeK = 1 diffusions = aSampleSpotT(1, 0, 0, 0, 0.2, 1, 50000) payoffs = pmax(0, diffusions - strikeK) mean(payoffs) ## [1] 0.08005113 Comparing the result to the Black Scholes solution: \\[ \\mathrm C(\\mathrm S,\\mathrm t)= \\mathrm N(\\mathrm d_1)\\mathrm S - \\mathrm N(\\mathrm d_2) \\mathrm K \\mathrm e^{-rt} \\label{eq:2} \\] where \\(d_1\\), \\(d_2\\) and \\(N(x)\\) is defined as: \\[ \\mathrm d_1= \\frac{1}{\\sigma \\sqrt{\\mathrm t}} \\left[\\ln{\\left(\\frac{S}{K}\\right)} + t\\left(r + \\frac{\\sigma^2}{2} \\right) \\right] \\] \\[ \\mathrm d_2= \\frac{1}{\\sigma \\sqrt{\\mathrm t}} \\left[\\ln{\\left(\\frac{S}{K}\\right)} + t\\left(r - \\frac{\\sigma^2}{2} \\right) \\right] \\] \\[ N(x)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} \\mathrm e^{-\\frac{1}{2}z^2} dz \\label{eq:5} \\] Now substituting in the values: \\[ \\mathrm d_1= \\frac{1}{0.2 \\sqrt{1}} \\left[\\ln{\\left(\\frac{1}{1}\\right)} + 1\\left(0 + \\frac{0.2^2}{2} \\right) \\right]= 0.1 \\] \\[ \\mathrm d_1= \\frac{1}{0.2 \\sqrt{1}} \\left[\\ln{\\left(\\frac{1}{1}\\right)} + 1\\left(0 - \\frac{0.2^2}{2} \\right) \\right]=-0.1 \\] \\[ N(d_1)=N(0.1)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{0.1} \\mathrm e^{-\\frac{1}{2}z^2} dz = 0.5398 \\] \\[ N(d_2)=N(-0.1)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{-.1} \\mathrm e^{-\\frac{1}{2}z^2} dz = 0.4602 \\] \\[ \\mathrm C(1,1)= (0.5398)(1) - (0.4602)(1) \\mathrm e^{-(0)(1)} \\approx 0.0796 \\] Good start! Rates, dividends and repo are assumed to be zero. Also that volatility is constant. We could do better by incorporating changes to these assumptions in later chapters. Up till this point our monte carlo simulations used random normal deviates that mimic randomness from the R function rnorm. Had we prefer our simulations to done by quasi- monte carlo, we will want to use low-discrepancy sequences instead of random numbers. The R function sobol from library randtoolbox provides such number generation. library(randtoolbox) aSampleSpotT_QMC = function(s0, r, d, q, sig, dt, nsims) { sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * sobol(nsims, normal = TRUE) * sqrt(dt)) sT } diffusions_QMC = aSampleSpotT_QMC(1, 0, 0, 0, 0.2, 1, 10000) payoffs_QMC = pmax(0, diffusions_QMC - strikeK) mean(payoffs_QMC) ## [1] 0.07958281 We see the results are very similar and also expects lower variance compare to ordinary monte carlo simulations. 3.1 Noncallable Non-callable payoffs are structures that have a fixed maturity. Structure that have possible earlier redemption or termination than this fixed maturity are called callable payoffs. 3.1.1 Digitals An example of a digit is one that pays X at maturity when the underlying is at or above a certain barrier, and pays nothing when the underlying is below, it is also called a up and in digit option. There are also versions; an up and out digit which the structure pays X unless the underlying is at or above a certain barrier, a down and in digit is equivalent to the up and out digit, and a down and out digit which is the same as a up and in digit. There are also variants of when the knocking in or out observation is carried out. A common type is called the European (or at maturity) observation which checks if the condition is satisfied only once at end of the product tenor. American observation type is as common, which checks for the condition on a daily close frequency. Other variants include quarterly, monthly or intraday observation frequency. set.seed(1) numSteps = 52 # weekly numTraj_digit = 2 manyTraj_digit = matrix(rep(1, numSteps*numTraj_digit), nrow = numTraj_digit) for (i in 2:numSteps) manyTraj_digit[,i] = aSampleSpotT(manyTraj_digit[,i-1], 0, 0, 0, 0.2, 1/numSteps, numTraj_digit) Supposed we have bought two 1 year european up and in digit 10% with barrier striked at 110% on same underlying above. Two sample trajectories below show that path 1 performed +26%, while path 2 only ended up +1%. According to the payoff, the first product will pay a 10% payout while the second product does not. See Figure 3.1: ## Closing price at end of Year 1 for Path 1: 1.264054 ## Closing price at end of Year 1 for Path 2: 1.012484 Figure 3.1: 2 separate trajectories; Left path ends below the strike and receives a 10% payout, the right path does not pay any. Blue line denotes the strike barrier at 110% of initial spot. Pricing this payoff is similar to that of a call option, except when the option is in the money, it pays the digit coupon instead of the performance of the underlying minus its strike. We see it cost about 3%. digitK = 1.1 digitCpn = 0.1 digitPays = (diffusions &gt; digitK)*digitCpn mean(digitPays) ## [1] 0.02832 3.1.2 Put Down and In Like the digital down and in option above, a put down and in option knocks in when an underlying ends below a certain barrier. However, when the condition is satisfied, the put comes into existence and so the payoff is that of a vanilla put option. We therefore need to be given the put strike in order to determine the payoff. Let’s say we sell a 1y put down and in on the same underlying as before, with european (at maturity) down and in barrier 80% and put strike 100%. For a change of pace we proceed to the price before visualising what a sample path and its payoff is. pdiK = 1 eki80Barrier = 0.8 pdi80Hit = diffusions &lt;= eki80Barrier putPays = pmax(0, pdiK - diffusions) pdi80Pays = putPays*as.double(pdi80Hit) mean(-1 * pdi80Pays) # price of short pdi with eki = 80% and strike = 100% ## [1] -0.04257959 We will use the convention of a negative premium for investor receiving the premium instead of paying the premium. If we think of the knock-in feature on a short put as protection, that is the option seller sold a put that will not be in the money unless the underlying has first broken the knock in barrier, then we should expect a put down and in with european barrier at 80% to bring less value than one with barrier at 90%. Both of which has to be cheaper than a straight put, or a put without knock-in feature. pdi_comparison = c(mean(-1 * pdi80Pays), mean(-1 * pdi90Pays), mean(-1 * putPays)) pdi_comparison ## [1] -0.04257959 -0.06891423 -0.07918612 We see the seller of the different puts receives more if he sold a put down and in with higher knock-in barrier, or when there is no barrier (a put). Looking consistent! By the same argument, a put down and in with american (daily close) knock-in observation type costs more than the european type, since there are more opportunities for the product to be knocked in. We delay this comparison on observation frequency to the next section. In structured products, puts with knock-in features are very common, since they provide some protection for the investors unless the underlying has severely underperformed. set.seed(8) numTraj_pdi = 2 manyTraj_pdi = matrix(rep(1, numSteps*numTraj_pdi), nrow = numTraj_pdi) for (i in 2:numSteps) manyTraj_pdi[,i] = aSampleSpotT(manyTraj_pdi[,i-1], 0, 0, 0, 0.2, 1/numSteps, numTraj_digit) Figure 3.2: 2 separate trajectories; Left: Path is not below the KI barrier, so has no value even though it is below the strike. Right: Path ends below KI barrier. 3.1.3 Call Up and Out In a call up and out, if the underlying is observed to breach a certain barrier X, the call is knocked out, it no longer exists. This means even if at maturity the underlying closing much higher than the strike, there is no payout. Assuming the knock out barrier is X and strike is at the money, another way to see the value hierarchy is to say the call up and out is to a call spread ATM/X, what the call spread is to a vanilla call. While the call spread capped the upside to make it cheaper than the call, the call up and out removes the entire payoff when it reaches a certain barrier. callK = 1 diffusions2y = aSampleSpotT_QMC(1, 0.05, 0, 0, 0.2, 2, 10000) payoffs2y = pmax(0, diffusions2y - callK) cat(&quot;Price of 2y atm call: &quot;, mean(payoffs2y)) ## Price of 2y atm call: 0.1780866 Imagine an investor buys a 2y call up &amp; out with american daily close style knock out observation frequency on an underlying with 20% annualised volatility, drift = 5%. The investor should expect to pay much lesser for this than a 2y vanilla call on the same underlying. akoBarrier = 1.4 numTraj = 15 yrs = 2 numStepsDaily = 252 # 2 years daily observation callTraj = matrix(rep(1, numStepsDaily*yrs*numTraj), nrow = numTraj) for (i in 2:(numStepsDaily*yrs)) callTraj[,i] = aSampleSpotT(callTraj[,i-1], 0.05, 0, 0, 0.2, yrs/(numStepsDaily*yrs), numTraj) cuoTraj = callTraj for (i in 1:numTraj) for (j in 1:(numStepsDaily*yrs)) if (callTraj[i, j] &gt; akoBarrier) { cuoTraj[i, j:(numStepsDaily*yrs)] = NA break; } Figure 3.3: Left: Paths with knock out at 140%. Right: No knock out feature. 3.1.4 Combinations Using a combinations of call, put and digital options we could put together an exotic payoff that fits investor’s risk appetite. For example, suppose an investor has a view that several underlyings will perform marginally well in the short term, but also thinks that there might be a slight chance of limited underperformance. Since the investor holds a bullish view on a basket of underlyings, it is sensible to observe the entire basket but base the performance on the worst performing underlying. We can therefore structure a payoff that pays an upside at maturity on the maximum of the worst-of call or a worst-of digit up and in. That is, \\(Max( digit coupon, perf)\\). If we set the digit strike to be at the money and the digit amount to be 10%, at maturity any marginal upside performance will pay 10% and may potentially lead to larger payouts if the performance exceeds 110%. To finance this upside (nothing is free) the investor would have to sell a put. We would want to add protection on the short put by adding a european down and in barrier since we expect there to be a chance of underperformance. Table 3.1: 3 correlated underlyings undl1 undl2 undl3 undl1 1.0 0.6 0.6 undl2 0.6 1.0 0.6 undl3 0.6 0.6 1.0 We assume there are 3 basket of underlyings with their returns well correlated, and all of them have constant annualised volatilities of 25%. Furthermore we assume their drifts are 1% per annum, that is \\(r - d - q = 0.01\\). set.seed(1) benUndls = nrow(corr_ben) benSteps = 52 # weekly benTraj = matrix(rep(1, benSteps*benUndls), nrow = benUndls) for (i in 2:benSteps) benTraj[,i] = corrSpot(benTraj[,i-1], 0.03, 0.01, 0.01, 0.25, 1/benSteps, corr_ben) benWoTraj = apply(benTraj, 2, min) tail(benWoTraj, 1) # worst performance at maturity ## [1] 0.9590089 Figure 3.4: A basket of 3 underlyings (in grey) and the worst-of underlying (in blue) We see the worst performance at maturity is down around 4%. Because the worst performance did not end at or above the digit strike, there was no coupon paid. The call was also not in the money. However as a saving grace, the put had a knock-in protection and the barrier was not barrier since it required the worst performance to be below 80%. For clarify we include the maturity payoff diagram. Figure 3.5: Payoff diagram of the product at maturity. Worst performance ended at 96%, above the protection barrier so no downside loss. 3.2 Callable Autocallable payoffs have features that allow them to “mature” earlier than their stated expiry when a condition is satisfied. During early redemption the investor gets to receive back their full notional before the contractual maturity. If the payoff has any downside risk at maturity, being autocallable also means the investor no longer gets exposed to the downside. In practice, distributors of structure products make their commission from each sale, when a product get redeemed they get an opportunity to pitch another product to their clients, these reasons make autocallable product fairly popular structures. The condition to be satisfied could be linked to a stock’s performance. An example would be the product automatically early redeeems if the stock’s daily closing price ever breaches a certain price level before maturity. On early redemption the investor may also receive an upside. We look at some possible upsides on autocallable payoffs below. 3.2.1 Fixed Coupon Autocallable Fixed coupon autocallables pays a guaranteed coupon to the investor at pre-specified times during the product. The observation of autocall condition can be made the same as these coupon payout timings. As an example, assume an investor buys a two year 8% annualised fixed coupon autocallable note linked to one stock. The autocall condition (or event) is observed quarterly over the one year and the 8 quarterly fixed coupons will be paid at each of these observation timings. The autocall event is satisfied if the stock performs better than it’s initial spot at each of this fixings. When the event triggers, the period’s coupon and the notional paid on the note is returned to the investor. In other to pay these upside, the product embeds a short put striked at the money. We assume the stock has a constant 30% annual volatility, drift and rates are equal zero. A sample quarterly close of this stock is: set.seed(1) fcn_numSteps = 8 # 8 qtrly obs fcn_oneTraj = rep(1, fcn_numSteps+1) for (i in 2:(fcn_numSteps+1)) fcn_oneTraj[i] = aSampleSpotT(fcn_oneTraj[i-1], 0, 0, 0, 0.3, 2/fcn_numSteps, 1) cat(&quot;Stock price at each of the 8 quarterly close: &quot;, fcn_oneTraj) ## Stock price at each of the 8 quarterly close: 1 0.9001282 0.9149173 0.7981044 1.002529 1.041542 0.9106307 0.9687454 1.070093 We see that during the first 9 months, the quarterly closes were not above the initial price, so there was no early redemption. The guaranteed quarterly 2% coupons were also paid, so the investor received 6% up till the 3rd quarter. On the end of year 1, the underlying closed around 100.3%, just barely over the initial spot. Since there is an autocallble feature in this note. The investor receives his notional plus the final 2% on the end of year 1. The product then early terminates and investor no longer receives further coupons or is exposed to the downside at maturity. If there were no autocall feature in the payoff, the client would have received a further year of coupons. The put he sold did not end up in the money. Therefore the total return were have been 16% over entire tenor. Pricing this product is a matter of simulation the stock diffusions and evaluation the payoff, that is determining the cashflows of the product for each sample trajectory. For this stylised example we also assuming rates were zero, so no discounting of the cashflows is needed. # generate the diffusion set.seed(1) fcn_nsims = 10000 fcn_manyTraj = matrix(rep(1, (fcn_numSteps+1)*fcn_nsims), nrow = fcn_nsims) for (i in 2:(fcn_numSteps+1)) fcn_manyTraj[,i] = aSampleSpotT(fcn_manyTraj[,i-1], 0, 0, 0, 0.3, 2/fcn_numSteps, fcn_nsims) # evaluate the payoff at each observation fcn_payoffs = matrix(rep(0, (fcn_numSteps+1)*fcn_nsims), nrow = fcn_nsims) # upside for (i in 1:fcn_nsims) for (j in 2:fcn_numSteps) { spot = fcn_manyTraj[i, j] if (spot &gt; 1) { fcn_payoffs[i, j] = 0.02 if (j != fcn_numSteps) fcn_payoffs[i, (j+1):fcn_numSteps] = 0 break; } else { fcn_payoffs[i, j] = 0.02 } } # downsides for (i in 1:fcn_nsims) { if (sum(fcn_manyTraj[i,1:(fcn_numSteps+1)] &gt; 1) &lt; 0.5) fcn_payoffs[i, fcn_numSteps+1] = -max(0, 1 - fcn_manyTraj[i, fcn_numSteps+1]) } # sum all cashflows and take the average fcn_retPerTraj = apply(fcn_payoffs, 1, sum) mean(fcn_retPerTraj) ## [1] -0.02590366 If the issuer and distributor had sold at par the note to the end investor at these stated terms, they would collectively kept 2.6% as margins and hedging costs. 3.2.2 Snowball Coupon Autocallable 3.2.3 Issuercallable In Progress Also see Chapter 5 "],
["sensi.html", "Chapter 4 Sensitivity 4.1 Vol 4.2 Spot 4.3 Correl", " Chapter 4 Sensitivity In Chapter 3 we tried to obtain an expected price of products. In this chapter we want to understand the sensitivities of these expectations. For example, when one particular variable changes, what is the effect it would have on the expectation. In finance speak, when the variable is the spot price, this sensitivity is called the Delta. Another variable of interest is the sensitivity to volatility (which is called Vega). Some people are not fans of technical terms so we prefer to call the sensitivities the change in expected price due to a change in some variable. In practice, exotic payoffs cannot be solved by closed-form formulas, so the method of partial differentiation is generally not applicable in obtaining the sensitivities. Here we look at methods of finite difference approximation since they are easy to understand and implement. Several types of finite differencing approximations are available - forward difference, backward difference, and central difference. Suppose the variable of interest is \\(\\theta\\) and it changes by amount \\(h\\). The expected price at a particular value of this variable can be represented as \\(F(\\theta)\\), the forward difference \\(\\Delta_{F}\\) is computed as such: \\[ \\Delta_{F} = \\frac{\\bar F(\\theta + h) - \\bar F(\\theta)}{h} \\] where \\(\\bar F(\\theta + h)\\) is the expected price of the payoff when the variable is \\(\\theta + h\\). The central difference \\(C(\\theta)\\) is computed as such: \\[ \\Delta_{C} = \\frac{\\bar C(\\theta + h) - \\bar C(\\theta - h)}{2h} \\] where \\(\\bar C(\\theta + h)\\) is the expected price of the payoff when the variable is to \\(\\theta + h\\). 4.1 Vol call_px(aSpot = 1, aVol = 0.2) ## [1] 0.07958281 vecVols = c(0.19, 0.21) callPxAtDiffVol = c(call_px(aSpot = 1, aVol = vecVols[1]), call_px(aSpot = 1, aVol = vecVols[2])) plot(vecVols, callPxAtDiffVol, type = &quot;l&quot;) # per 0.1% change in spot call_vol = (callPxAtDiffVol[2] - callPxAtDiffVol[1])/2 call_vol * 100 # per 1% change ## [1] 0.3964437 fcn_px(aSpot = 1, aKO = 1.02, aVol = 0.3) ## [1] -0.0395444 vecVols = c(0.29, 0.31) fcnPxAtDiffVol = c(fcn_px(aSpot = 1, aKO = 1.02, aVol = vecVols[1]), fcn_px(aSpot = 1, aKO = 1.02, aVol = vecVols[2])) fcn_vol = (fcnPxAtDiffVol[2] - fcnPxAtDiffVol[1])/2 fcn_vol * 100 # vega per 1 vol pt change ## [1] -0.2759809 4.2 Spot call_px(aSpot = 1, aStrike = 1) ## [1] 0.07958281 vecSpots = c(99, 101)/100 callPxAtDiffSpot = sapply(vecSpots, call_px, nsims = 10000) plot(vecSpots, callPxAtDiffSpot, type = &quot;l&quot;) # per 0.1% change in spot call_delta = (callPxAtDiffSpot[2] - callPxAtDiffSpot[1])/2 call_delta * 100 # per 1% change ## [1] 0.5396399 fcn_px(aSpot = 1, aKO = 1, aRate = 0) ## [1] -0.03675524 vecSpots = c(99, 101)/100 fcnPxAtDiffSpot = sapply(vecSpots, fcn_px, nsims = 10000, aKO = 1.02, aRate = 0) #plot(vecSpots, fcnPxAtDiffSpot, type = &quot;l&quot;) # per 0.1% change in spot fcn_delta = (fcnPxAtDiffSpot[2] - fcnPxAtDiffSpot[1])/2 fcn_delta * 100 # per 1% change in % ## [1] 0.3860328 4.3 Correl TODO "],
["lsmc.html", "Chapter 5 Longstaff Schwartz", " Chapter 5 Longstaff Schwartz In Progress TODO: Show least square regression example to compute expected price, vs exercise/exit price. Determine optimal exercise strategy. "],
["quirk.html", "Chapter 6 Quirkiness 6.1 Inversion 6.2 Gap", " Chapter 6 Quirkiness Here we look at some interesting behaviour of exotic structures 6.1 Inversion 6.1.1 Delta Even on a bullish payoff, after product issues the delta of a product can become negative when near an certain product features such as an Autocall barrier TODO: Compute delta just before KO observation when just below KO Barrier 6.1.2 Vega On lookback payoffs, the vega during different periods of the product can flip signs TODO: Compute vega during lookback observation period, vs vega after lb obs period. 6.2 Gap Many exotic structures have digital payoffs. For example the put down and in seen in Chapter 3.1.2 can have a jump in value if the barrier is breached. TODO: Compute delta just before barrier to show explosive sensi. "],
["refer.html", "Chapter 7 References 7.1 Other projects", " Chapter 7 References The below made this webpage possible: Bookdown CBOE option price R Github Countless helpful people 7.1 Other projects Market hours widget Machine learning pricer "]
]
