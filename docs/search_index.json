[
["index.html", "Notes Chapter 1 Diffusion 1.1 Basket 1.2 Worst-of 1.3 Best-of", " Notes Ivan Tan 2017-03-05 Chapter 1 Diffusion In no-arbitrage pricing we one way to model a stock diffusion is using the following GBM model: \\[S_T = S_0 \\cdot e^{\\Big( r-d-q -\\frac{1}{2}\\sigma^2 \\Big)\\cdot T + \\sigma \\sqrt{T}\\cdot W_T } \\] Given the drift and volatility parameters we can simulate sample final spot levels as such: aSampleSpotT = function(s0, r, d, q, sig, dt, nsims) { sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * rnorm(nsims) * sqrt(dt)) sT } cat(&quot;Spot after 1 year: &quot;, aSampleSpotT(1, 0.04, 0.01, 0, 0.2, 1, 1)) ## Spot after 1 year: 0.9434656 If required we could compute over several short periods to create a trajectory. Then repeat it many times to see how the diffusion is going to look like. Assuming we will drift the equity by 0% p.a., that is \\(r - d - q = 0\\), and it has annualised volatility of 20%, Let’s plot several trajectories or paths. See Figure 1.1: numSteps = 52 # weekly oneTraj = rep(1, numSteps) for (i in 2:numSteps) oneTraj[i] = aSampleSpotT(oneTraj[i-1], 0, 0, 0, 0.2, 1/numSteps, 1) cat(&quot;First 5 weekly close: &quot;, oneTraj[1:5]) ## First 5 weekly close: 1 0.9998615 1.013997 1.004675 1.023341 par(mfrow = c(1, 2)) plot(oneTraj, type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(manyTraj), max(manyTraj))) box() axis(side = 2) plot(manyTraj[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(manyTraj), max(manyTraj))) box() axis(side = 2) for (i in 2:nrow(manyTraj)) lines(manyTraj[i,], type = &quot;l&quot;) Figure 1.1: Left: 1 path, Right: 30 paths 1.1 Basket What was done above assumed each path (which can be though as one underlying by itself) is independent of another, although with the same drift and volatility. However, when attempting to simulate several underlyings, it would not be unreasonable to consider the underlyings are correlated, even with different market parameters. As an example we have a basket on three underlyings, their log returns all have pairwise correlation of 90%, see Table 1.1. The (multivariate) GBM process can be extended to correlated underlyings, with their correlations preserved in the multivariate random process. One way of generating a correlated multivariate random \\(W_T\\) vector is to left-multiply a lower triangle Cholesky decomposed correlation matrix to an uncorrelated random vector.1 2 corr_more = matrix(c(1.0, 0.9, 0.9, 0.9, 1.0, 0.9, 0.9, 0.9, 1.0), nrow = 3, dimnames = list(c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;), c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;))) Table 1.1: 3 highly correlated underlyings undl1 undl2 undl3 undl1 1.0 0.9 0.9 undl2 0.9 1.0 0.9 undl3 0.9 0.9 1.0 corrSpot = function(s0, r, d, q, sig, dt, corrMat) { numUndls = nrow(corrMat) correlatedRV = as.double(t(chol(corrMat)) %*% rnorm(numUndls)) sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * correlatedRV * sqrt(dt)) sT } numUndls = nrow(corr_more) numSteps = 52 # weekly corrTraj = matrix(rep(1, numSteps*numUndls), nrow = numUndls) for (i in 2:numSteps) corrTraj[,i] = corrSpot(corrTraj[,i-1], 0, 0, 0, 0.2, 1/numSteps, corr_more) Table 1.2: First 5 weekly close of 3 correlated undls wk1 wk2 wk3 wk4 wk5 undl1 1 1.0018599 0.9845011 0.9836299 0.9960825 undl2 1 0.9888889 0.9849943 0.9905277 1.0161799 undl3 1 0.9775961 0.9719928 0.9586636 0.9755517 Sample paths of the underlyings. Underlying 1 in Black, Underlying 2 in Red, and Underlying 3 in Green. See Figure 1.2: Figure 1.2: Separate simulations of the basket trajectories 1.2 Worst-of From a basket of underlyings, we could choose the lowest performing underlying and call it the worst-of underlying. Doing this selection over the entire tenor we can visual what a worst-of trajectory looks like. corr_less = matrix(c(1.0, 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0), nrow = 3, dimnames = list(c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;), c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;))) corrTraj2 = matrix(rep(1, numSteps*numUndls), nrow = numUndls) for (i in 2:numSteps) corrTraj2[,i] = corrSpot(corrTraj2[,i-1], 0, 0, 0, 0.15, 1/numSteps, corr_less) To make it obvious that a worst-of “underlying” can be different as different point of time, we choose to create a much lower correlation basket of underlyings, and reduced the annualised volatility to 15%. In this stylised result we see how the worst-of underlying can change over time. print(corrTraj2[,1:5]) # First 5 weekly close of 3 less correlated undls ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0.9824495 0.9733751 0.9715178 0.9792299 ## [2,] 1 0.9773642 0.9500451 0.9781026 0.9937370 ## [3,] 1 1.0513659 1.0344515 1.0185185 1.0117457 woTraj = apply(corrTraj2, 2, min) print(woTraj[1:5]) # First 5 weekly close of the worst &quot;underlying&quot; ## [1] 1.0000000 0.9773642 0.9500451 0.9715178 0.9792299 Let’s plot a one sample of the basket trajectories, then overlap with the worst-of “underlying” (in blue). See Figure 1.3: par(mfrow = c(1, 2)) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = basketCols[i]) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, col = &quot;azure3&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = &quot;azure3&quot;) lines(woTraj, type = &quot;l&quot;, col = &quot;blue&quot;) Figure 1.3: A basket of 3 underlyings (in grey) and the worst-of underlying (in blue) When I first started it made no sense why anyone would want to buy a call option that tracks the worst performance. Turns out it meant for investors who have a bullish view on a basket of underlyings. Tracking on the worst-of is a lot cheaper than buying a call that is based of the average performance. As we’ll see in Chapter 3, this makes possible some interesting exotic payoffs. 1.3 Best-of Having seen a worst-of underlying, there is no reason why we cannot have a best-of version. This time we select the best performing underlying instead of the worst. Unless the worst-of call, the best-of call is more expensive than basing of an average performance of the basket of underlying. However if you have a bearish view, buying a put or shorting a call is now a lot more attractive. print(corrTraj2[,1:5]) # First 5 weekly close of 3 correlated undls ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0.9824495 0.9733751 0.9715178 0.9792299 ## [2,] 1 0.9773642 0.9500451 0.9781026 0.9937370 ## [3,] 1 1.0513659 1.0344515 1.0185185 1.0117457 boTraj = apply(corrTraj2, 2, max) print(woTraj[1:5]) # First 5 weekly close of the worst &quot;underlying&quot; ## [1] 1.0000000 0.9773642 0.9500451 0.9715178 0.9792299 Again, we see there is no need for the best-of “underlying” to be the same underlying in the basket from start to end. See Figure 1.4: par(mfrow = c(1, 2)) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = basketCols[i]) plot(corrTraj2[1,], type = &quot;l&quot;, col = &quot;azure3&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = &quot;azure3&quot;) lines(boTraj, type = &quot;l&quot;, col = &quot;blue&quot;) Figure 1.4: A basket of 3 underlyings (in grey) and the best-of underlying (in blue) And with many repeated simulations of the 3 underlyings. On the right we also overlay in blue the best-of “underlying” for each simulation. Notice how this “underlying” drifts differently compared to the 3 actual underlyings (in red, blue and black). "],
["volsurf.html", "Chapter 2 Volatility Surface 2.1 Implied vol surface 2.2 Local vol surface", " Chapter 2 Volatility Surface Exotics can be highly sensitive to the vol surface. Term structure and skew on the surface implies that volatility of an underlying are not regarded as constant in the market. Before thinking about the implications of this to price, we should provide means of seeing this surface from market data. Using option prices of an underlying we could reconstruct the implied volatility surface. Below we demostrate how to construct the SPX implied volatility surface using option data from CBOE. CBOEhttp://www.cboe.com/delayedquote/quote-table-download provides downloading of delayed quotes of options prices. If we enter SPX as the index quote we can obtain a table that looks like this. ## Spec PBid PAsk CP Type ## 1 17 Feb 500.00 (SPXW1728B500) 1864.8 1868.5 C Euro ## 2 17 Feb 500.00 (SPXW1728B500-E) 1864.8 1868.5 C Euro ## 3 17 Feb 600.00 (SPXW1728B600) 1764.8 1768.5 C Euro ## 4 17 Feb 600.00 (SPXW1728B600-E) 1764.8 1768.5 C Euro ## 5 17 Feb 700.00 (SPXW1728B700) 1664.8 1668.5 C Euro ## 6 17 Feb 700.00 (SPXW1728B700-E) 1664.8 1668.5 C Euro The data contains all the information required for us to compute an implied volatility that leads to the (mid) price of this option. 2.1 Implied vol surface Since the actual surface does not contain equal grid points and sufficient data, we make a decide to smooth the surface, then interpolate missing value within points. Here we create a 40 by 40 grid so that the plot looks sufficiently smooth. df_call &lt;- subset(SPX.IV, Type == &quot;C&quot;) df_call$StrikePct = df_call$Strike/df_call$Spot x &lt;- df_call$StrikePct y &lt;- as.numeric(df_call$dtExpiry) z &lt;- df_call$IVMid s &lt;- interp(x, y, z, nx=40, ny = 40, linear = T) nrz = nrow(s$z) ncz = ncol(s$z) jet.colors = colorRampPalette(c(&quot;blue&quot;, &quot;green&quot;)) nbcol = 100 color = jet.colors(nbcol) zfacet = s$z[-1, -1] + s$z[-1, -ncz] + s$z[-nrz, -1] + s$z[-nrz, -ncz] facetcol = cut(zfacet, nbcol) TTM &lt;- as.numeric(as.Date(s$y, origin = &quot;1970-01-01&quot;) - df_call$dtTrade[1])/365 persp(s$x, TTM, s$z * 100, col = color[facetcol], xlab = &quot;\\nMoneyness&quot;, ylab = &quot;\\nExpiry (Yr)&quot;, zlab = &quot;\\nVolatility (%)&quot;, theta = 40, phi = 25, ticktype = &quot;detailed&quot;) From the plot we see the volatility is generally moving in the opposite direction of moneyness. Since we computed moneyness as strike divided by the spot price, we could understand this as implied volatility being higher when strike is lower than the spot price. We say generally moving in opposite direction because this is only one portion of the entire surface. There are other sections of the section where the shape of the curvature can look different (or upwards sloping instead of downwards as shown here. 2.2 Local vol surface TODO: Build LV surface using IV surface. Plot 3d cube. Show crazy fluctuations if IV is not smooth. "],
["payoff.html", "Chapter 3 Payoff 3.1 Noncallable 3.2 Autocallable 3.3 Issuercallable", " Chapter 3 Payoff From the diffusions created in Chapter 1, we could evaluate them based on the payoff of the product. To start off we price a vanilla call options, then compare the result with the closed-form Black Scholes solution. For a 1 year european call option strike at the money on an underlying with zero drift and 20% annualised volatility, we get a price of around 8%. strikeK = 1 diffusions = aSampleSpotT(1, 0, 0, 0, 0.2, 1, 50000) payoffs = pmax(0, diffusions - strikeK) mean(payoffs) ## [1] 0.08014617 Comparing the result to the Black Scholes solution: \\[ \\mathrm C(\\mathrm S,\\mathrm t)= \\mathrm N(\\mathrm d_1)\\mathrm S - \\mathrm N(\\mathrm d_2) \\mathrm K \\mathrm e^{-rt} \\label{eq:2} \\] where \\(d_1\\), \\(d_2\\) and \\(N(x)\\) is defined as: \\[ \\mathrm d_1= \\frac{1}{\\sigma \\sqrt{\\mathrm t}} \\left[\\ln{\\left(\\frac{S}{K}\\right)} + t\\left(r + \\frac{\\sigma^2}{2} \\right) \\right] \\] \\[ \\mathrm d_2= \\frac{1}{\\sigma \\sqrt{\\mathrm t}} \\left[\\ln{\\left(\\frac{S}{K}\\right)} + t\\left(r - \\frac{\\sigma^2}{2} \\right) \\right] \\] \\[ N(x)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} \\mathrm e^{-\\frac{1}{2}z^2} dz \\label{eq:5} \\] Now substituting in the values: \\[ \\mathrm d_1= \\frac{1}{0.2 \\sqrt{1}} \\left[\\ln{\\left(\\frac{1}{1}\\right)} + 1\\left(0 + \\frac{0.2^2}{2} \\right) \\right]= 0.1 \\] \\[ \\mathrm d_1= \\frac{1}{0.2 \\sqrt{1}} \\left[\\ln{\\left(\\frac{1}{1}\\right)} + 1\\left(0 - \\frac{0.2^2}{2} \\right) \\right]=-0.1 \\] \\[ N(d_1)=N(0.1)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{0.1} \\mathrm e^{-\\frac{1}{2}z^2} dz = 0.5398 \\] \\[ N(d_2)=N(-0.1)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{-.1} \\mathrm e^{-\\frac{1}{2}z^2} dz = 0.4602 \\] \\[ \\mathrm C(1,1)= (0.5398)(1) - (0.4602)(1) \\mathrm e^{-(0)(1)} \\approx 0.0796 \\] Good start! Here rates, dividends and repo are assumed to be zero. Also that volatility is constant. We could do better by incorporating these changes in later chapters. Up till this point we generated random normal values to mimic randomness using the function rnorm for monte carlo simulations. Had we decided we prefer quasi monte carlo simulations and want to use low-discrepancy sequences instead of random numbers because, the function sobol from randtoolbox could be used. library(randtoolbox) aSampleSpotT_QMC = function(s0, r, d, q, sig, dt, nsims) { sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * sobol(nsims, normal = TRUE) * sqrt(dt)) sT } diffusions_QMC = aSampleSpotT_QMC(1, 0, 0, 0, 0.2, 1, 10000) payoffs_QMC = pmax(0, diffusions_QMC - strikeK) mean(payoffs_QMC) ## [1] 0.07958281 Averaging over much lesser trajectories we expect similar results and see they are indeed very similar. 3.1 Noncallable Non-callable payoffs are structures that have a fixed maturity. Structures that may terminate earlier than this fixed maturity are called callable payoffs. 3.1.1 Digitals An example of a digit is one that pays X at maturity when the underlying is at or above a certain barrier, and pays nothing when the underlying is below, it is also called a up and in digit option. There are also versions; an up and out digit which the structure pays X unless the underlying is at or above a certain barrier, a down and in digit is equivalent to the up and out digit, and a down and out digit which is the same as a up and in digit. There are also variants of when the knocking in or out observation is carried out. A common type is called the European (or at maturity) observation which checks if the condition is satisfied only once at end of the product tenor. American observation type is as common, which checks for the condition on a daily close frequency. Other variants include quarterly, monthly or intraday observation frequency. set.seed(1) numTraj_digit = 2 manyTraj_digit = matrix(rep(1, numSteps*numTraj_digit), nrow = numTraj_digit) for (i in 2:numSteps) manyTraj_digit[,i] = aSampleSpotT(manyTraj_digit[,i-1], 0, 0, 0, 0.2, 1/numSteps, numTraj_digit) Supposed we have bought two 1 year european up and in digit 10% with barrier striked at 110% on same underlying above. Two sample trajectories below show that path 1 performed +26%, while path 2 only ended up +1%. According to the payoff, the first product will pay a 10% payout while the second product does not. See Figure 3.1: ## Closing price at end of Year 1 for Path 1: 1.264054 ## Closing price at end of Year 1 for Path 2: 1.012484 Figure 3.1: 2 separate trajectories; Left path ends below the strike and receives a 10% payout, the right path does not pay any. Blue line denotes the strike barrier at 110% of initial spot. Pricing such a product is always similar to that of a call option, except when the option is in the money, it pays the digit coupon instead of the performance of the underlying minus its strike. We see it cost about 3%. digitK = 1.1 digitCpn = 0.1 digitPays = (diffusions &gt; digitK)*digitCpn mean(digitPays) ## [1] 0.028294 3.1.2 Put Down and In Like the digital down and in option above, a put down and in option knocks in when an underlying ends below a certain barrier. However, when the condition is satisfied, the put comes into existence and so the payoff is that of a vanilla put option. Therefore we need also need to know the put strike in order to determine the payoff. Let’s say we sell a 1y put down and in on the same underlying as before, with european (at maturity) down and in barrier 80% and strike 100%. For a change of pace we proceed to the price before visualising what a sample path and its payoff is. pdiK = 1 eki80Barrier = 0.8 pdi80Hit = diffusions &lt;= eki80Barrier putPays = pmax(0, pdiK - diffusions) pdi80Pays = putPays*as.double(pdi80Hit) mean(-1 * pdi80Pays) # price of short pdi with eki = 80% and strike = 100% ## [1] -0.04383925 We will use the convention of a negative premium for investor receiving the premium instead of paying the premium. If we think of the knock-in feature on a short put as protection, that is the option seller sold a put that will not be in the money unless the underlying has first broken the knock in barrier, then we should expect a put down and in with european barrier at 80% to bring less value than one with barrier at 90%. Both of which has to be cheaper than a straight put, or a put without knock-in feature. pdi_comparison = c(mean(-1 * pdi80Pays), mean(-1 * pdi90Pays), mean(-1 * putPays)) pdi_comparison ## [1] -0.04383925 -0.07036428 -0.08051571 We see the seller of the different puts receives more if he sold a put down and in with higher knock-in barrier, or when there is no barrier (a put). Looking consistent! By the same argument, a put down and in with american (daily close) knock-in observation type costs more than the european type, since there are more opportunities for the product to be knocked in. We delay this comparison on observation frequency to the next section. In structured products, puts with knock-in features are very common, since they provide some protection for the investors unless the underlying has severely underperformed. set.seed(8) numTraj_pdi = 2 manyTraj_pdi = matrix(rep(1, numSteps*numTraj_pdi), nrow = numTraj_pdi) for (i in 2:numSteps) manyTraj_pdi[,i] = aSampleSpotT(manyTraj_pdi[,i-1], 0, 0, 0, 0.2, 1/numSteps, numTraj_digit) Figure 3.2: 2 separate trajectories; Left: Path is not below the KI barrier, so has no value even though it is below the strike. Right: Path ends below KI barrier. 3.1.3 Call Up and Out In a call up and out, if the underlying is observed to breach a certain barrier X, the call is knocked out, it no longer exists. This means even if at maturity the underlying closing much higher than the strike, there is no payout. Assuming the knock out barrier is X and strike is at the money, another way to see the value hierarchy is to say the call up and out is to a call spread ATM/X, what the call spread is to a vanilla call. While the call spread capped the upside to make it cheaper than the call, the call up and out removes the entire payoff when it reaches a certain barrier. callK = 1 diffusions2y = aSampleSpotT_QMC(1, 0.05, 0, 0, 0.2, 2, 10000) payoffs2y = pmax(0, diffusions2y - callK) cat(&quot;Price of 2y atm call: &quot;, mean(payoffs2y)) ## Price of 2y atm call: 0.1780866 Imagine an investor buys a 2y call up &amp; out with american daily close style knock out observation frequency on an underlying with 20% annualised volatility, drift = 5%. The investor should expect to pay much lesser for this than a 2y vanilla call on the same underlying. akoBarrier = 1.4 numTraj = 20 yrs = 2 numStepsDaily = 252 # 2 years daily observation callTraj = matrix(rep(1, numStepsDaily*yrs*numTraj), nrow = numTraj) for (i in 2:(numStepsDaily*yrs)) callTraj[,i] = aSampleSpotT(callTraj[,i-1], 0.05, 0, 0, 0.2, yrs/(numStepsDaily*yrs), numTraj) cuoTraj = callTraj for (i in 1:numTraj) for (j in 1:(numStepsDaily*yrs)) if (callTraj[i, j] &gt; akoBarrier) { cuoTraj[i, j:(numStepsDaily*yrs)] = NA break; } Figure 3.3: Left: Paths with knock out at 140%. Right: No knock out feature. 3.1.4 Combinations 3.2 Autocallable 3.2.1 Snowball 3.2.2 Phoenix 3.2.3 Fixed Coupons Notes 3.3 Issuercallable In Progress Also see Chapter 5 "],
["sensi.html", "Chapter 4 Sensitivity 4.1 Vol 4.2 Correl 4.3 Drift", " Chapter 4 Sensitivity In Chapter 3 we tried to obtain an expected price of products. In this chapter we want to understand the sensitivities of these expectations. For example, when one particular variable changes, what effect would it have on the the expectation. In finance speak, when the variable is the spot price, this sensitivity is called the Delta. Another variable of interest is the sensitivity to the volatility variable (which we called Vega). Most people are not fans of technical terms so we prefer to refer to these sensitivities as the change in expected price due to a change in some variable. In practice, exotic payoff generally cannot be priced by a closed-form formula, so partial differentiation is also generally not applicable when attempting to obtain the sensitivities. Here we look methods of finite difference approximation since they are easy to understand and implement. Two kinds of finite differences calculation is available, the forward difference and the central difference estimator. Suppose the variable of interest is \\(\\theta\\) and it changes by amount \\(h\\). The expected price at a particular value of this variable is \\(F(\\theta)\\), the forward difference \\(\\Delta_{F}\\) is computed as: \\[ \\Delta_{F} = \\frac{\\bar F(\\theta + h) - \\bar F(\\theta)}{h} \\] where \\(\\bar F(\\theta + h)\\) is the expected value when the variable is equal to \\(\\theta + h\\). The central difference \\(C(\\theta)\\) is computed as: \\[ \\Delta_{C} = \\frac{\\bar C(\\theta + h) - \\bar C(\\theta - h)}{2h} \\] where \\(\\bar C(\\theta + h)\\) is the expected value when the variable is equal to \\(\\theta + h\\). 4.1 Vol TODO: Show products that are vega negative. 4.2 Correl TODO: Show bullish products that are correl offer. Long worst of call = CA, Long worst of put = CA. 4.3 Drift TODO: Showbullish products are divs and repo bid. "],
["lsmc.html", "Chapter 5 Longstaff Schwartz", " Chapter 5 Longstaff Schwartz In Progress TODO: Show least square regression example to compute expected price, vs exercise/exit price. Determine optimal exercise strategy. "],
["scen.html", "Chapter 6 Scenario", " Chapter 6 Scenario In Progress Those interested in exotic payoffs often want to understand the behaviour of the value the product after issuance if some variable (such as spot level) changes. "],
["quirk.html", "Chapter 7 Quirkiness 7.1 Inversion 7.2 Gap 7.3 Qto 7.4 Correl", " Chapter 7 Quirkiness Here we look at some interesting behaviour of exotic structures 7.1 Inversion 7.1.1 Delta Even on a bullish payoff, after product issues the delta of a product can become negative when near an certain product features such as an Autocall barrier TODO: Compute delta just before KO observation when just below KO Barrier 7.1.2 Vega On lookback payoffs, the vega during different periods of the product can flip signs TODO: Compute vega during lookback observation period, vs vega after lb obs period. 7.2 Gap Many exotic structures have digital payoffs. For example the put down and in seen in Chapter 3.1.2 can have a jump in value if the barrier is breached. TODO: Compute delta just before barrier to show explosive sensi, or large gamma. 7.3 Qto It is quite common to see structure products issued in product currency which is different from the underlying currency. For example in a 1 year EUR Note linked to APPLE, the holder of the product pays and gets paid in EUR, with the payoff defined entired based on the performance only on the stock. TODO: short formula on payoff only depends on eqty perf 7.4 Correl TODO: Compute price of outperformance between 2 basket (i.e. long basket - short basket). Determine that correlation between long basket and short basket is Bid, correlation within each basket is Offer. "],
["refer.html", "Chapter 8 References", " Chapter 8 References The below made this webpage possible: Bookdown CBOE option price R Github Countless helpful people "]
]
