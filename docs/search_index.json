[
["index.html", "Notes Chapter 1 Diffusion 1.1 Basket 1.2 Worst-of 1.3 Best-of", " Notes Ivan Tan 2017-03-06 Chapter 1 Diffusion In no-arbitrage pricing one way to model a stock diffusion is using the following GBM model: \\[S_T = S_0 \\cdot e^{\\Big( r-d-q -\\frac{1}{2}\\sigma^2 \\Big)\\cdot T + \\sigma \\sqrt{T}\\cdot W_T } \\] Given the drift and volatility market parameters we can simulate sample final spot levels as such: aSampleSpotT = function(s0, r, d, q, sig, dt, nsims) { sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * rnorm(nsims) * sqrt(dt)) sT } cat(&quot;Spot after 1 year: &quot;, aSampleSpotT(1, 0.04, 0.01, 0, 0.2, 1, 1)) ## Spot after 1 year: 1.058742 If required we may also compute over several consecutive periods to generate a trajectory. If we repeat this process many times we see how the stock diffusion is going to look like. Assuming we will drift the stock by 0% p.a., that is market parameters \\(r - d - q = 0\\), and that it has constant annualised volatility of 20%, Let’s plot several trajectories. See Figure 1.1: numSteps = 52 # weekly oneTraj = rep(1, numSteps) for (i in 2:numSteps) oneTraj[i] = aSampleSpotT(oneTraj[i-1], 0, 0, 0, 0.2, 1/numSteps, 1) cat(&quot;First 5 weekly close: &quot;, oneTraj[1:5]) ## First 5 weekly close: 1 0.9732981 0.9148824 0.9325205 0.9330477 par(mfrow = c(1, 2)) plot(oneTraj, type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(manyTraj), max(manyTraj))) box() axis(side = 2) plot(manyTraj[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(manyTraj), max(manyTraj))) box() axis(side = 2) for (i in 2:nrow(manyTraj)) lines(manyTraj[i,], type = &quot;l&quot;) Figure 1.1: Left: 1 path, Right: 30 paths 1.1 Basket It was assumed that each path (and can also be thought as each underlying) is independent of one another. However, when attempting to simulate several underlyings, it would not be unreasonable to consider the underlyings are actually correlated. They are likely to also have different market parameters. As an example we have a basket on three underlyings, with log returns of each underlying having pairwise correlation of 90%. See Table 1.1. The (multivariate) GBM process can be extended to underlyings that are correlated. Their correlations are preserved within the multivariate random portion of the process. One way of generating a correlated multivariate random \\(W_T\\) vector is to left-multiply a lower triangular Cholesky decomposed matrix to an uncorrelated multivariate random vector.1 2 corr_more = matrix(c(1.0, 0.9, 0.9, 0.9, 1.0, 0.9, 0.9, 0.9, 1.0), nrow = 3, dimnames = list(c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;), c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;))) Table 1.1: 3 highly correlated underlyings undl1 undl2 undl3 undl1 1.0 0.9 0.9 undl2 0.9 1.0 0.9 undl3 0.9 0.9 1.0 corrSpot = function(s0, r, d, q, sig, dt, corrMat) { numUndls = nrow(corrMat) correlatedRV = as.double(t(chol(corrMat)) %*% rnorm(numUndls)) sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * correlatedRV * sqrt(dt)) sT } numUndls = nrow(corr_more) numSteps = 52 # weekly corrTraj = matrix(rep(1, numSteps*numUndls), nrow = numUndls) for (i in 2:numSteps) corrTraj[,i] = corrSpot(corrTraj[,i-1], 0, 0, 0, 0.2, 1/numSteps, corr_more) Table 1.2: First 5 weekly close of 3 correlated undls wk1 wk2 wk3 wk4 wk5 undl1 1 0.9976845 0.9944772 1.0154737 0.9759374 undl2 1 0.9856863 0.9936068 1.0187560 0.9845475 undl3 1 0.9905005 0.9772523 0.9880967 0.9559537 Sample paths of the underlyings. In black is underlying 1, in red underlying 2, in green underlying 3. See Figure 1.2: Figure 1.2: Two separate simulations of the paths of the underlyings in the basket 1.2 Worst-of From a basket of underlyings, we could choose the lowest performing underlying and call it the worst-of underlying. Making this choice over the entire tenor of the product we can visual what a worst-of trajectory looks like. corr_less = matrix(c(1.0, 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0), nrow = 3, dimnames = list(c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;), c(&quot;undl1&quot;, &quot;undl2&quot;, &quot;undl3&quot;))) corrTraj2 = matrix(rep(1, numSteps*numUndls), nrow = numUndls) for (i in 2:numSteps) corrTraj2[,i] = corrSpot(corrTraj2[,i-1], 0, 0, 0, 0.15, 1/numSteps, corr_less) To make it obvious that a worst-of “underlying” does not have to be the same underlying at different point of time, we chose to create a much lower correlated basket of underlyings. We also chose to fix the annualised volatility of these underlyings constant at 15%. In this stylised result we see how the worst-of underlying may differ over time. print(corrTraj2[,1:5]) # First 5 weekly close of 3 less correlated undls ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0.9579938 0.9608714 0.9303943 0.9096714 ## [2,] 1 1.0023613 1.0167211 1.0334814 1.0329243 ## [3,] 1 0.9628227 0.9567382 0.9415245 0.9399668 woTraj = apply(corrTraj2, 2, min) print(woTraj[1:5]) # First 5 weekly close of the worst &quot;underlying&quot; ## [1] 1.0000000 0.9579938 0.9567382 0.9303943 0.9096714 Let’s plot one sample of all underlying paths. On the right we overlay the worst-of “underlying” in blue while greying out the actual underlying paths. See Figure 1.3: par(mfrow = c(1, 2)) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = basketCols[i]) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, col = &quot;azure3&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = &quot;azure3&quot;) lines(woTraj, type = &quot;l&quot;, col = &quot;blue&quot;) Figure 1.3: A basket of 3 underlyings (in grey) and the worst-of underlying (in blue) A relevant question is why anyone would want to buy a call option that tracks the worst performance instead of the average performance, since the alternative is very likely to pay more at maturity. A sensitive answer is that if the investor has a bullish view on the entire basket, buying a worst-of call option is a lot more affordable than buying a call that is based on the average performance. As we’ll see in Chapter 3, this makes possible some interesting exotic payoffs. 1.3 Best-of Having seen a worst-of underlying, there is no reason why we cannot have a best-of version. Unlike the worst-of call option, a best-of call is more expensive than the average of call. However, if you have a bearish view, buying a best-of put is much more affordable. Likewise, selling a best-of call brings the investor much more premium. print(corrTraj2[,1:5]) # First 5 weekly close of 3 correlated undls ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0.9579938 0.9608714 0.9303943 0.9096714 ## [2,] 1 1.0023613 1.0167211 1.0334814 1.0329243 ## [3,] 1 0.9628227 0.9567382 0.9415245 0.9399668 boTraj = apply(corrTraj2, 2, max) print(woTraj[1:5]) # First 5 weekly close of the worst &quot;underlying&quot; ## [1] 1.0000000 0.9579938 0.9567382 0.9303943 0.9096714 Again, we see there is no need for the best-of “underlying” to be the same underlying in the basket from start to end of the product tenor. See Figure 1.4: par(mfrow = c(1, 2)) plot(corrTraj2[1,], type = &quot;l&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = basketCols[i]) plot(corrTraj2[1,], type = &quot;l&quot;, col = &quot;azure3&quot;, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, ylim = c(min(corrTraj2), max(corrTraj2))) box() axis(side = 2) for (i in 2:nrow(corrTraj2)) lines(corrTraj2[i,], type = &quot;l&quot;, col = &quot;azure3&quot;) lines(boTraj, type = &quot;l&quot;, col = &quot;blue&quot;) Figure 1.4: A basket of 3 underlyings (in grey) and the best-of underlying (in blue) Now we repeat the over many simulations of the 3 underlyings paths. On the right we overlay in blue the best-of “underlying” of each simulation. "],
["volsurf.html", "Chapter 2 Volatility Surface 2.1 Implied vol surface 2.2 Local vol surface", " Chapter 2 Volatility Surface Exotic payoffs can be very sensitive to volatility. The existence of a term and skew structure on the volatility surface implies that an underlying is regarded as having different volatility at different spot or time. The sensitivity to volatility means that our estimation of the price needs to incorporate the entire surface as an input. Before thinking about the implications of this, we should provide means of producing the surface. One way is to use the market data of option prices on an underlying to reconstruct the implied volatility surface. Below we demostrate how to construct the SPX implied volatility surface using option prices from CBOE. CBOEhttp://www.cboe.com/delayedquote/quote-table-download provides downloading of delayed option quotes. If we enter SPX as the index ticker we can obtain a table that looks like this: ## Spec PBid PAsk CP Type ## 1 17 Feb 500.00 (SPXW1728B500) 1864.8 1868.5 C Euro ## 2 17 Feb 500.00 (SPXW1728B500-E) 1864.8 1868.5 C Euro ## 3 17 Feb 600.00 (SPXW1728B600) 1764.8 1768.5 C Euro ## 4 17 Feb 600.00 (SPXW1728B600-E) 1764.8 1768.5 C Euro ## 5 17 Feb 700.00 (SPXW1728B700) 1664.8 1668.5 C Euro ## 6 17 Feb 700.00 (SPXW1728B700-E) 1664.8 1668.5 C Euro The data contains enough information to reproduce an implied volatility that leads to the quoted price of an option. 2.1 Implied vol surface Generally the market data does not contain sufficient data points, we therefore make a decision to interpolate within the points. Here we create a 40 by 40 equidistance grid of points so that the plot will look smooth. df_call &lt;- subset(SPX.IV, Type == &quot;C&quot;) df_call$StrikePct = df_call$Strike/df_call$Spot x &lt;- df_call$StrikePct y &lt;- as.numeric(df_call$dtExpiry) z &lt;- df_call$IVMid s &lt;- interp(x, y, z, nx=40, ny = 40, linear = T) nrz = nrow(s$z) ncz = ncol(s$z) jet.colors = colorRampPalette(c(&quot;blue&quot;, &quot;green&quot;)) nbcol = 100 color = jet.colors(nbcol) zfacet = s$z[-1, -1] + s$z[-1, -ncz] + s$z[-nrz, -1] + s$z[-nrz, -ncz] facetcol = cut(zfacet, nbcol) TTM &lt;- as.numeric(as.Date(s$y, origin = &quot;1970-01-01&quot;) - df_call$dtTrade[1])/365 persp(s$x, TTM, s$z * 100, col = color[facetcol], xlab = &quot;\\nMoneyness&quot;, ylab = &quot;\\nExpiry (Yr)&quot;, zlab = &quot;\\nVolatility (%)&quot;, theta = 40, phi = 25, ticktype = &quot;detailed&quot;) From the plot we see the volatility is moving in the opposite direction of moneyness. Moneyness was computed as the strike price divided by the spot price. We can understand also interpret this as the implied volatility being higher when strike price is lower than the spot price. However this is not always true, there other sections of the surface (further strikes and expiries) where the curvature is differently shaped. That is, in far out (or in) of the region shown above, the shape can be upward sloping instead of downward sloping. 2.2 Local vol surface TODO: Build LV surface using IV surface. Plot 3d chart. Show fluctuations if IV data points are not smooth. "],
["payoff.html", "Chapter 3 Payoff 3.1 Noncallable 3.2 Autocallable 3.3 Issuercallable", " Chapter 3 Payoff From the diffusions created in Chapter 1, we could evaluate them based on the payoff of the product. To start off we price a vanilla call option, then compare the result with the closed-form Black Scholes solution. For a 1 year european call option strike at the money on an underlying with zero drift and constant 20% annualised volatility, we see the stimulations gave a price of about 8%. strikeK = 1 diffusions = aSampleSpotT(1, 0, 0, 0, 0.2, 1, 50000) payoffs = pmax(0, diffusions - strikeK) mean(payoffs) ## [1] 0.07949793 Comparing the result to the Black Scholes solution: \\[ \\mathrm C(\\mathrm S,\\mathrm t)= \\mathrm N(\\mathrm d_1)\\mathrm S - \\mathrm N(\\mathrm d_2) \\mathrm K \\mathrm e^{-rt} \\label{eq:2} \\] where \\(d_1\\), \\(d_2\\) and \\(N(x)\\) is defined as: \\[ \\mathrm d_1= \\frac{1}{\\sigma \\sqrt{\\mathrm t}} \\left[\\ln{\\left(\\frac{S}{K}\\right)} + t\\left(r + \\frac{\\sigma^2}{2} \\right) \\right] \\] \\[ \\mathrm d_2= \\frac{1}{\\sigma \\sqrt{\\mathrm t}} \\left[\\ln{\\left(\\frac{S}{K}\\right)} + t\\left(r - \\frac{\\sigma^2}{2} \\right) \\right] \\] \\[ N(x)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} \\mathrm e^{-\\frac{1}{2}z^2} dz \\label{eq:5} \\] Now substituting in the values: \\[ \\mathrm d_1= \\frac{1}{0.2 \\sqrt{1}} \\left[\\ln{\\left(\\frac{1}{1}\\right)} + 1\\left(0 + \\frac{0.2^2}{2} \\right) \\right]= 0.1 \\] \\[ \\mathrm d_1= \\frac{1}{0.2 \\sqrt{1}} \\left[\\ln{\\left(\\frac{1}{1}\\right)} + 1\\left(0 - \\frac{0.2^2}{2} \\right) \\right]=-0.1 \\] \\[ N(d_1)=N(0.1)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{0.1} \\mathrm e^{-\\frac{1}{2}z^2} dz = 0.5398 \\] \\[ N(d_2)=N(-0.1)=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{-.1} \\mathrm e^{-\\frac{1}{2}z^2} dz = 0.4602 \\] \\[ \\mathrm C(1,1)= (0.5398)(1) - (0.4602)(1) \\mathrm e^{-(0)(1)} \\approx 0.0796 \\] Good start! Rates, dividends and repo are assumed to be zero. Also that volatility is constant. We could do better by incorporating changes to these assumptions in later chapters. Up till this point our monte carlo simulations used random normal deviates that mimic randomness from the R function rnorm. Had we prefer our simulations to done by quasi- monte carlo, we will want to use low-discrepancy sequences instead of random numbers. The R function sobol from library randtoolbox provides such number generation. library(randtoolbox) aSampleSpotT_QMC = function(s0, r, d, q, sig, dt, nsims) { sT = s0 * exp((r - d - q - 0.5 * sig^2)*dt + sig * sobol(nsims, normal = TRUE) * sqrt(dt)) sT } diffusions_QMC = aSampleSpotT_QMC(1, 0, 0, 0, 0.2, 1, 10000) payoffs_QMC = pmax(0, diffusions_QMC - strikeK) mean(payoffs_QMC) ## [1] 0.07958281 We see the results are very similar and expect lower variance compare to ordinary monte carlo simulations. 3.1 Noncallable Non-callable payoffs are structures that have a fixed maturity. Structure that have possible earlier redemption or termination than this fixed maturity are called callable payoffs. 3.1.1 Digitals An example of a digit is one that pays X at maturity when the underlying is at or above a certain barrier, and pays nothing when the underlying is below, it is also called a up and in digit option. There are also versions; an up and out digit which the structure pays X unless the underlying is at or above a certain barrier, a down and in digit is equivalent to the up and out digit, and a down and out digit which is the same as a up and in digit. There are also variants of when the knocking in or out observation is carried out. A common type is called the European (or at maturity) observation which checks if the condition is satisfied only once at end of the product tenor. American observation type is as common, which checks for the condition on a daily close frequency. Other variants include quarterly, monthly or intraday observation frequency. set.seed(1) numTraj_digit = 2 manyTraj_digit = matrix(rep(1, numSteps*numTraj_digit), nrow = numTraj_digit) for (i in 2:numSteps) manyTraj_digit[,i] = aSampleSpotT(manyTraj_digit[,i-1], 0, 0, 0, 0.2, 1/numSteps, numTraj_digit) Supposed we have bought two 1 year european up and in digit 10% with barrier striked at 110% on same underlying above. Two sample trajectories below show that path 1 performed +26%, while path 2 only ended up +1%. According to the payoff, the first product will pay a 10% payout while the second product does not. See Figure 3.1: ## Closing price at end of Year 1 for Path 1: 1.264054 ## Closing price at end of Year 1 for Path 2: 1.012484 Figure 3.1: 2 separate trajectories; Left path ends below the strike and receives a 10% payout, the right path does not pay any. Blue line denotes the strike barrier at 110% of initial spot. Pricing this payoff is similar to that of a call option, except when the option is in the money, it pays the digit coupon instead of the performance of the underlying minus its strike. We see it cost about 3%. digitK = 1.1 digitCpn = 0.1 digitPays = (diffusions &gt; digitK)*digitCpn mean(digitPays) ## [1] 0.028054 3.1.2 Put Down and In Like the digital down and in option above, a put down and in option knocks in when an underlying ends below a certain barrier. However, when the condition is satisfied, the put comes into existence and so the payoff is that of a vanilla put option. We therefore need to be given the put strike in order to determine the payoff. Let’s say we sell a 1y put down and in on the same underlying as before, with european (at maturity) down and in barrier 80% and put strike 100%. For a change of pace we proceed to the price before visualising what a sample path and its payoff is. pdiK = 1 eki80Barrier = 0.8 pdi80Hit = diffusions &lt;= eki80Barrier putPays = pmax(0, pdiK - diffusions) pdi80Pays = putPays*as.double(pdi80Hit) mean(-1 * pdi80Pays) # price of short pdi with eki = 80% and strike = 100% ## [1] -0.04223061 We will use the convention of a negative premium for investor receiving the premium instead of paying the premium. If we think of the knock-in feature on a short put as protection, that is the option seller sold a put that will not be in the money unless the underlying has first broken the knock in barrier, then we should expect a put down and in with european barrier at 80% to bring less value than one with barrier at 90%. Both of which has to be cheaper than a straight put, or a put without knock-in feature. pdi_comparison = c(mean(-1 * pdi80Pays), mean(-1 * pdi90Pays), mean(-1 * putPays)) pdi_comparison ## [1] -0.04223061 -0.06903801 -0.07937410 We see the seller of the different puts receives more if he sold a put down and in with higher knock-in barrier, or when there is no barrier (a put). Looking consistent! By the same argument, a put down and in with american (daily close) knock-in observation type costs more than the european type, since there are more opportunities for the product to be knocked in. We delay this comparison on observation frequency to the next section. In structured products, puts with knock-in features are very common, since they provide some protection for the investors unless the underlying has severely underperformed. set.seed(8) numTraj_pdi = 2 manyTraj_pdi = matrix(rep(1, numSteps*numTraj_pdi), nrow = numTraj_pdi) for (i in 2:numSteps) manyTraj_pdi[,i] = aSampleSpotT(manyTraj_pdi[,i-1], 0, 0, 0, 0.2, 1/numSteps, numTraj_digit) Figure 3.2: 2 separate trajectories; Left: Path is not below the KI barrier, so has no value even though it is below the strike. Right: Path ends below KI barrier. 3.1.3 Call Up and Out In a call up and out, if the underlying is observed to breach a certain barrier X, the call is knocked out, it no longer exists. This means even if at maturity the underlying closing much higher than the strike, there is no payout. Assuming the knock out barrier is X and strike is at the money, another way to see the value hierarchy is to say the call up and out is to a call spread ATM/X, what the call spread is to a vanilla call. While the call spread capped the upside to make it cheaper than the call, the call up and out removes the entire payoff when it reaches a certain barrier. callK = 1 diffusions2y = aSampleSpotT_QMC(1, 0.05, 0, 0, 0.2, 2, 10000) payoffs2y = pmax(0, diffusions2y - callK) cat(&quot;Price of 2y atm call: &quot;, mean(payoffs2y)) ## Price of 2y atm call: 0.1780866 Imagine an investor buys a 2y call up &amp; out with american daily close style knock out observation frequency on an underlying with 20% annualised volatility, drift = 5%. The investor should expect to pay much lesser for this than a 2y vanilla call on the same underlying. akoBarrier = 1.4 numTraj = 20 yrs = 2 numStepsDaily = 252 # 2 years daily observation callTraj = matrix(rep(1, numStepsDaily*yrs*numTraj), nrow = numTraj) for (i in 2:(numStepsDaily*yrs)) callTraj[,i] = aSampleSpotT(callTraj[,i-1], 0.05, 0, 0, 0.2, yrs/(numStepsDaily*yrs), numTraj) cuoTraj = callTraj for (i in 1:numTraj) for (j in 1:(numStepsDaily*yrs)) if (callTraj[i, j] &gt; akoBarrier) { cuoTraj[i, j:(numStepsDaily*yrs)] = NA break; } Figure 3.3: Left: Paths with knock out at 140%. Right: No knock out feature. 3.1.4 Combinations Using a combinations of call, put and digital options we could put together an exotic payoff that fits investor’s risk appetite. For example, suppose an investor has a view that several underlyings will perform marginally well in the short term, but also thinks that there might be a slight chance of limited underperformance. Since the investor holds a bullish view on a basket of underlyings, it is sensible to observe the entire basket but base the performance on the worst performing underlying. We can therefore structure a payoff that pays an upside at maturity on the maximum of the worst-of call or a worst-of digit up and in. That is, \\(Max( digit coupon, perf)\\). If we set the digit strike to be at the money and the digit amount to be 10%, at maturity any marginal upside performance will pay 10% and may potentially lead to larger payouts if the performance exceeds 110%. To finance this upside (nothing is free) the investor would have to sell a put. We would want to add protection on the short put by adding a european down and in barrier since we expect there to be a chance of underperformance. Table 3.1: 3 correlated underlyings undl1 undl2 undl3 undl1 1.0 0.6 0.6 undl2 0.6 1.0 0.6 undl3 0.6 0.6 1.0 We assume there are 3 basket of underlyings with their returns well correlated, and all of them have constant annualised volatilities of 25%. Furthermore we assume their drifts are 1% per annum, that is \\(r - d - q = 0.01\\). set.seed(1) benUndls = nrow(corr_ben) benSteps = 52 # weekly benTraj = matrix(rep(1, benSteps*benUndls), nrow = benUndls) for (i in 2:benSteps) benTraj[,i] = corrSpot(benTraj[,i-1], 0.03, 0.01, 0.01, 0.25, 1/benSteps, corr_ben) benWoTraj = apply(benTraj, 2, min) tail(benWoTraj, 1) # worst performance at maturity ## [1] 0.9590089 Figure 3.4: A basket of 3 underlyings (in grey) and the worst-of underlying (in blue) We see the worst performance at maturity is down around 4%. Because the worst performance did not end at or above the digit strike, there was no coupon paid. The call was also not in the money. However as a saving grace, the put had a knock-in protection and the barrier was not barrier since it required the worst performance to be below 80%. For clarify we include the maturity payoff diagram. Figure 3.5: Payoff diagram of the product at maturity. Worst performance ended at 96%, above the protection barrier so no downside loss. 3.2 Autocallable 3.2.1 Snowball 3.2.2 Phoenix 3.2.3 Fixed Coupons Notes 3.3 Issuercallable In Progress Also see Chapter 5 "],
["sensi.html", "Chapter 4 Sensitivity 4.1 Vol 4.2 Correl 4.3 Drift", " Chapter 4 Sensitivity In Chapter 3 we tried to obtain an expected price of products. In this chapter we want to understand the sensitivities of these expectations. For example, when one particular variable changes, what is the effect it would have on the expectation. In finance speak, when the variable is the spot price, this sensitivity is called the Delta. Another variable of interest is the sensitivity to volatility (which is called Vega). Some people are not fans of technical terms so we prefer to call the sensitivities the change in expected price due to a change in some variable. In practice, exotic payoffs cannot be solved by closed-form formulas, so the method of partial differentiation is generally not applicable in obtaining the sensitivities. Here we look at methods of finite difference approximation since they are easy to understand and implement. Two types of finite differencing are available, the forward difference and the central difference approximation. Suppose the variable of interest is \\(\\theta\\) and it changes by amount \\(h\\). The expected price at a particular value of this variable can be represented as \\(F(\\theta)\\), the forward difference \\(\\Delta_{F}\\) is computed as such: \\[ \\Delta_{F} = \\frac{\\bar F(\\theta + h) - \\bar F(\\theta)}{h} \\] where \\(\\bar F(\\theta + h)\\) is the expected price of the payoff when the variable is \\(\\theta + h\\). The central difference \\(C(\\theta)\\) is computed as such: \\[ \\Delta_{C} = \\frac{\\bar C(\\theta + h) - \\bar C(\\theta - h)}{2h} \\] where \\(\\bar C(\\theta + h)\\) is the expected price of the payoff when the variable is to \\(\\theta + h\\). 4.1 Vol TODO 4.2 Correl TODO 4.3 Drift TODO "],
["lsmc.html", "Chapter 5 Longstaff Schwartz", " Chapter 5 Longstaff Schwartz In Progress TODO: Show least square regression example to compute expected price, vs exercise/exit price. Determine optimal exercise strategy. "],
["scen.html", "Chapter 6 Scenario", " Chapter 6 Scenario In Progress Those interested in exotic payoffs often want to understand the behaviour of the value the product after issuance if some variable (such as spot level) changes. "],
["quirk.html", "Chapter 7 Quirkiness 7.1 Inversion 7.2 Gap 7.3 Qto 7.4 Correl", " Chapter 7 Quirkiness Here we look at some interesting behaviour of exotic structures 7.1 Inversion 7.1.1 Delta Even on a bullish payoff, after product issues the delta of a product can become negative when near an certain product features such as an Autocall barrier TODO: Compute delta just before KO observation when just below KO Barrier 7.1.2 Vega On lookback payoffs, the vega during different periods of the product can flip signs TODO: Compute vega during lookback observation period, vs vega after lb obs period. 7.2 Gap Many exotic structures have digital payoffs. For example the put down and in seen in Chapter 3.1.2 can have a jump in value if the barrier is breached. TODO: Compute delta just before barrier to show explosive sensi. 7.3 Qto It is quite common to see structured products issued in product currency that differs from the underlying currency. For example, a 1 year EUR note linked to US underlying, the investor of the product pays and gets paid in EUR, but the value of the payoff is independent of the EURUSD fluctuations and is computed based only on the performance of the underlying. TODO: short formula on payoff only depends on eqty perf 7.4 Correl TODO: Compute price of outperformance between 2 basket (i.e. long basket - short basket). Determine that correlation between long basket and short basket is Bid, correlation within each basket is Offer. "],
["refer.html", "Chapter 8 References", " Chapter 8 References The below made this webpage possible: Bookdown CBOE option price R Github Countless helpful people "]
]
